# 复习要点

## GIT
* 总是出现"TCP connection reset by peer"的错误
> 是因为github把master分支重命名为main了。所以当你要push或者pull的时候应写为`git push/pull origin main`
> 或者在github网站上：settings>>Repositories>>修改默认分支名称
* 出现"Network file descriptor is not connected"的错误
> 因为我git push的时候没有加'-u'
* 建立仓库的步骤
> 1. 先在github上新建一个仓库 复制仓库地址
> 2. 在本地：
> > 1. `git init //git初始化`
> > 2. `git remote origin master 地址 //设置remote地址`
> > 3. `git pull origin master //获取远程仓库master分支上的内容`

> > 4. `git add .  / gaa  //将全部文件加入git版本管理 .的意思是将当前文件夹下的全部文件放到版本管理中`
> > 5. `git status / gsb  //显示有变更的文件`
> > 6. `git commit -m "message" / gcmsg "message" //提交暂存区到仓库`
> > 7. `git log / glol    //显示当前提交的分支（推出的话直接按Q）`
> > 8. `git push -u origin master / gp -u origin master //提交本地仓库到远程，第一次用-u，后面不在使用`

## 02最大子列和问题
* #### 我没有读懂分治法的含义
> **分治法**的思想采用了递归算法，每次递归都会找到一个中点，这里和二分法查找很像。但是在每一层递归里是**从mid往两边累加**计算最大值，而不是从头到尾累加。
* #### 题目要求返回子列的开头第一个数和最后一个数？
> 网上有的用的是结构体，这个我不太熟悉，我用的是指针。在每次递归中，每得到一次最大值，改变指针指向此时的i/j，两边统计完后两个指针分别指向左边和右边；比较完左右哪个最大值大后，再移动另一边的指针到最大值这边的mid上，但是如果加起来最大的话，则不需要移动
> > * 首先，指针的声明应赋值，否则指向内存中的关键部分不好收场
> > * 其次，指针作为函数调用时的形参时不应带\*号,应直接写名字
> > * 最后，改变指针指向的值时，应带\*号
* #### 在findmax函数中，应在最开始就判断low和high是否相等
> 这样做是因为 循环的主体只有一个数字时 不需要比较和累加，直接返回这个数就好
* #### 怎样保证返回的开头和结尾下标最小？
> 在统计左边最大值时，当最大值max和统计值sum相等时，指针也要指向此时的i。反之，在统计右边最大值时，这两者相等时则不需要改变指针指向。
* #### 为什么设置左边最大值lmax=a[mid],而右边的最大值rmax=0？
> 保证了当最大和序列中有负数时和当全为负数时程序的顺利执行。当最大和序列最后一部分和为零时，因为要保证最小的下标，当0是右边的最大值时，指针不动，要实现这一测试点，需要使rmax=0，且若rmax=sum时，指针不移动。当全为负数时，返回最大子列和为0，子列为整个数列，但是如果lmax=0的话，碰到负数不改变，则lmax永远为0，也就影响了后续的判断。 

那为啥rmax=0没关系？因为即使右边rmax始终为0，只要左边为负整体就为负。
* #### 这个递归算法的空间复杂度？
> 每次递归都要存储返回的信息
> 递归的空间复杂度为每次递归产生的空间复杂度×递归深度。
## 合并两个有序链表
* ##### 如何创建一个链表(List Read())
> 先定义一个指针，再让这个指针指向malloc出来的节点。（即头节点
* ####核心代码（List Merge()）
> \```
  while(p!=NULL&&q!=NULL){
   if(q->Data>p->Data){ 
      L->Next=p;
      L=L->Next;
      p=p->Next;                         
    }
    else{
      L->Next=q;
      L=L->Next;
      q=q->Next;                       
    }                        
  }
  if(p){
    L->Next=p;                                           
  }
  if(q){
    L->Next=q;      
  }
\```

## 一元多项式的加法与乘法
* 一直出现前三个测试点段错误最后一个测试点正确的情况
> 一步步排查，没想到原因会处在while的判断条件中
> 正确：`while(rear->next&&rear->next->expon>e)`
> 错误：`while(rear->next->expon>e&&rear->next)`
> ** 真他妈百思不得其解**
